\documentclass[12pt, letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}

\title{CS387 - Applied Cryptography}
\author{\'Angel Sola Orbaiceta}
\date{December 2021}

\begin{document}

\begin{titlepage}
  \maketitle
\end{titlepage}

\section{Concepts}

Given a message $m \in M$, where $M$ is the set of all possible messages, and a key $k \in K$, where $K$ is the set of all possible keys, an encryption function $E$ can be defined as:
\[
  E: M \times K \to C
\]
where $c \in C$ is the \emph{ciperthext} (being $C$ the set of all possible ciphertexts).
Conversely, a decryption function $D$ can be defined as:
\[
  D: C \times K \to M
\]

The \textbf{correctness property} states that, for all messages and keys, decrypting the result of encrypting a message must result in the message itself.
Mathematically:

\[
  \forall m,k: D_k (E_k(m)) = m
\]

The \textbf{security property} states that the ciphertext reveals nothing about the key or original message.

\subsection{One-Time Pad}

The one-time pad is based in the XOR ($\oplus$) function.
The XOR function satisfies the property that any value XOR-ed with itself equals zero: $x \oplus x = 0$.
The one-time pad uses this property so that, by using a key that's the same size as the ciphertext, we can do:

\[
  c = m \oplus k\\
\]
\[
  m = c \oplus k
\]

The one-time pad encryption and decryption functions are implemented in the \emph{source/one\_time\_pad.py} file.

\subsection{Perfect Cipher}

Recall that given two events $A$ and $B$ in the same probability space, the \textbf{conditional probability} of $B$ given that $A$ occured is:

\[
  P(B|A) = \frac{P(A \cap B)}{P(A)}
\]

Now, given two messages, $m$ and $m^*$ drawn from the set of messages $M$ are encrypted using a key $k \in K$ to produce a cypertext $c \in C$,
a \textbf{perfect cipher} must hold that:

\[
  P \left( m = m^* | E_k \left( m \right) = c \right) = P \left( m = m^* \right)
\]

We can now prove that the one-time pad is a perfect cipher as follows.
For the one-time pad:

\[
  P \left( E_k \left( m \right) = c \right) = \sum_{m_i \in M} \sum_{k_i \in K} \frac{P(E_{k_i} (m_i) = c)}{|M| \times |K|}
  = \frac{|M|}{|M| \times |K|}
  = \frac{1}{|K|}
\]
and, assuming a uniform distribution for the key space:

\[
  P \left( m = m^* \cap E_k(m) = c \right)
  = P(m = m^*) \times P(k = k^*)
  = \frac{P(m = m^*)}{|K|}
\]
Therefore:

\[
  P \left( m = m^* | E_k(m) = c \right) = \frac{\frac{P(m = m^*)}{|K|}}{\frac{1}{|K|}}
  = P(m = m^*)
\]
which means that the ciphertext reveals nothing about the key or original message.

\paragraph{Shanon's theorem} If a cipher is perfect, it must be impractical ($|K| \geq |M|$).


\section{Application of Symmetric Ciphers}

\paragraph{Kolmogorov complexity} The complexity $K$ of a sequence $s$ ($K(s)$) is the length of the shortest possible description of $s$.
$s$ is random if $K(s) = |s| + C$.
The Kolmogorov complexity is uncomputable.

\paragraph{A Pseudo-Random Number Generator (PRNG)} produces a long sequence of seemingly random bytes given an initial seed value.
In Linux, \emph{dev/random} can be used as a randomness pool.

\subsection{Modes Of Operation}

We assume the message we want to encrypt or decrypt can be broken into $n$ blocks of size $b$:

\[
  m = m_0, m_1, m_2, \dots, m_{n-1}
\]

\paragraph{Electronic Codebook Mode} (ECB) each block is encrypted independently from each other:

\[
  c_i = E_k (m_i)
\]
and decryption:

\[
  m_i = D_k (c_i)
\]

The problem with ECB mode is that it doesn't hide repetition: equal blocks encrypt to equal ciperthexts.
To run a cipher using the ECB mode of operation:

\begin{verbatim}
  $ py symmetric/block_cli.py -e -m ecb -f <file> -k <key>
\end{verbatim}

\paragraph{Cipher Block Chaining Mode (CBC)} the output of each block is XOR-ed with the input to the next block.
Encryption:

\[
  c_i = E_k (m_i \oplus c_{i - 1})
\]
and if an \textbf{initialization vector} is used, the first block:

\[
  c_0 = E_k (m_0 \oplus IV)
\]
and decryption:

\[
  m_i = D_k (c_i) \oplus c_{i-1}
\]
\[
  m_0 = D_k(c_0) \oplus IV
\]

To run a cipher using the CBC mode of operation:

\begin{verbatim}
  $ py symmetric/block_cli.py -e -m cbc -f <file> -k <key>
\end{verbatim}

\paragraph{Counter Mode (CTR)} uses a counter that increments for each block, which concatenated with a \textbf{nonce} is passed to the encryption function.
The result is then XOR-ed with the message blocks.
The benefit of CTR is that blocks can be encrypted and decrypted in parallel.

\[
  c_i = E_k(\mathtt{nonce} || i) \oplus m_i
\]
and decryption:

\[
  m_i = c_i \oplus D_k(\mathtt{nonce} || i)
\]

If the block size is 32 bytes (256 bits), the nonce and the counter can be 16 bytes (128 bits) each.
When concatenated, both make a 32 bytes sequence.

To run a cipher using the CTR mode of operation:

\begin{verbatim}
  $ py symmetric/block_cli.py -e -m ctr \
    -f <file> \
    -k <key> \
    -n <nonce>
\end{verbatim}

\subsection{Protocols}

A \textbf{protocol} is a precisely defined sequence of steps agreed upon two parties.
A \textbf{cryptographic protocol} involves shared secrets between the two parties, and, for it to be \textbf{secure}, it must provide some guarantees even if some participants cheat.


\subsection{Cryptographic Hash Functions}

A \textbf{hash function} $h = H(x)$ is a function defined over a large input domain which output is of a fixed --usually small-- length.
A regular hash function has the following properties:

\begin{itemize}
  \item compression: a large input domain is mapped to a small fixed output
  \item well distributed: $P(H(x) = i) \sim \frac{1}{N}$, where $N$ is the size of the output
\end{itemize}
Additionally, \textbf{cryptographic hash functions} must have the following properties:

\begin{itemize}
  \item pre-image resistance ("one-way ness"): given $h = H(x)$, it's hard to find $x$
  \item weak collision resistance: given $h = H(x)$, it's hard to find any $x'$ such that $H(x') = h$
  \item strong collision resistance: it's hard to find any pair $x$ and $y$ such that $H(x) = H(y)$
\end{itemize}

Given an ideal hash function with $N$ possible outputs, an attacker is expected to need:
\begin{itemize}
  \item weak: $\sim N$ guesses to find $x'$ where $H(x') = h$
  \item strong: $\sim \sqrt{N}$ guesses to find $x$, $y$ where $H(x) = H(y)$.
\end{itemize}

\paragraph{Salted password scheme} To securely store passwords and avoid dictionary attacks --where the attacker precomputes a list of password hashes--,
a good scheme is to hash the result of concatenating a \textbf{salt} (sequence or random bits) with the password: $H(\mathtt{salt} || \mathtt{password})$.
The salt can be stored together with the password; it's just used to avoid the dictionary attack.

\end{document}
